"use strict";angular.module("keta.servicesAccessToken",["keta.servicesAppContext"]).factory("ketaAccessToken",function($http,ketaAppContext){var accessToken=ketaAppContext.get("oauth.accessToken"),api={get:function(){return accessToken},set:function(token){angular.isDefined(token)&&angular.isString(token)&&(accessToken=token)},refresh:function(){return $http({method:"GET",url:"/refreshAccessToken"})}};return api}),angular.module("keta.servicesAppContext",[]).provider("ketaAppContext",function(){var appContext=angular.isDefined(window.appContext)?window.appContext:{};this.get=function(key){var obj=appContext;key=key.split(".");for(var i=0,l=key.length;l>i;i++){if(!angular.isDefined(obj[key[i]]))return null;obj=obj[key[i]]}return obj},this.$get=function(){var api={get:this.get};return api}}),angular.module("keta.servicesDevice",["keta.servicesEventBus","keta.servicesLogger"]).provider("ketaDevice",function(){var SERVICE_NAME="ketaDevice",SERVICE_ENDPOINT="devices",ERROR_NO_GUID="No guid found in device object",ERROR_ITEM_NOT_FOUND=-1;this.$get=function($rootScope,$q,$location,ketaEventBus,ketaLogger){var equals=function(deviceOne,deviceTwo){var matches=angular.isDefined(deviceOne.guid)&&angular.isDefined(deviceTwo.guid)&&deviceOne.guid===deviceTwo.guid;return matches},indexOfItem=function(item,list){var index=ERROR_ITEM_NOT_FOUND;return angular.forEach(list,function(object,idx){index===ERROR_ITEM_NOT_FOUND&&equals(item,object)&&(index=idx)}),index},processEvent=function(message,devices){if(angular.isDefined(message.type)&&angular.isDefined(message.value)&&angular.isDefined(message.value.guid)){var device=message.value;if(device.$$pristine=angular.copy(device),message.type===ketaEventBus.EVENT_CREATED)devices.push(device),ketaLogger.debug(SERVICE_NAME+':processEvent » device with guid "'+device.guid+'" created',device),$rootScope.$apply();else{var index=indexOfItem(device,devices);index!==ERROR_ITEM_NOT_FOUND?(message.type===ketaEventBus.EVENT_UPDATED&&(devices[index]=device,ketaLogger.debug(SERVICE_NAME+':processEvent » device with guid "'+device.guid+'" updated',device)),message.type===ketaEventBus.EVENT_DELETED&&(devices.splice(index,1),ketaLogger.debug(SERVICE_NAME+':processEvent » device with guid "'+device.guid+'" deleted',device)),$rootScope.$apply()):ketaLogger.warning(SERVICE_NAME+':processEvent » device with guid "'+device.guid+'" not found',device)}}},processAction=function(message,registerListener){var deferred=$q.defer();return ketaEventBus.send(SERVICE_ENDPOINT,message,function(response){if(angular.isDefined(response.code)&&angular.isDefined(response.result)&&response.code===ketaEventBus.RESPONSE_CODE_OK){if(registerListener){var listenerUUID="CLIENT_"+ketaEventBus.generateUUID()+"_deviceSetListener",deviceFilter={},deviceProjection={};angular.isDefined(message.params)&&null!==message.params&&(angular.isDefined(message.params.filter)&&(deviceFilter=message.params.filter),angular.isDefined(message.params.projection)&&(deviceProjection=message.params.projection)),ketaEventBus.registerBusHandler(listenerUUID,function(message){processEvent(message,response.result.items)}),ketaEventBus.send(SERVICE_ENDPOINT,{action:"registerDeviceSetListener",body:{deviceFilter:deviceFilter,deviceProjection:deviceProjection,replyAddress:listenerUUID}},function(response){response.code!==ketaEventBus.RESPONSE_CODE_OK&&ketaLogger.info(SERVICE_ENDPOINT+":registerDeviceSetListener",response)}),response.result.$$listenerUUID=listenerUUID,angular.forEach(response.result.items,function(item){item.$$pristine=angular.copy(item)})}angular.isDefined(response.result.items)?deferred.resolve(response.result):angular.isDefined(response.result.type)&&response.result.type!==ketaEventBus.EVENT_FAILED?deferred.resolve(response.result.type===ketaEventBus.EVENT_UPDATED?response.result.value:response.result):deferred.reject("Failed")}else deferred.reject(angular.isDefined(response.message)?response.message:"Unknown error")},function(error){deferred.reject(error)}),deferred.promise},responsePromise=function(message,resolve){var deferred=$q.defer();return resolve?deferred.resolve(message):deferred.reject(message),deferred.promise},getChanges=function(prevTags,currentTags){var changes={};return angular.forEach(currentTags,function(tag,name){angular.isDefined(prevTags[name])&&angular.equals(prevTags[name].value,tag.value)||(changes[name]={value:tag.value,oca:tag.oca})}),angular.equals(changes,{})?!1:changes},checkIfGuidExists=function(device){return angular.isDefined(device.guid)?!0:responsePromise({code:ketaEventBus.RESPONSE_CODE_BAD_REQUEST,message:ERROR_NO_GUID},!1)},api={ERROR_NO_GUID:ERROR_NO_GUID,read:function(params,registerListener){var flag=angular.isDefined(registerListener)?registerListener:!0;return processAction({action:"getDevices",params:angular.isDefined(params)?params:null,body:null},flag)},create:function(device){var valid=checkIfGuidExists(device);return valid===!0?processAction({action:"createDevice",params:null,body:device}):valid},update:function(device){var valid=checkIfGuidExists(device);if(valid===!0){var originalDevice=angular.copy(device.$$pristine),updatedDevice=angular.copy(device);delete updatedDevice.$$pristine;var changes=getChanges(originalDevice.tagValues,updatedDevice.tagValues);return changes?processAction({action:"updateDevice",params:{deviceId:device.guid},body:{tagValues:changes}}):responsePromise(device,!0)}return valid},"delete":function(device){var valid=checkIfGuidExists(device);return valid===!0?processAction({action:"deleteDevice",params:{deviceId:device.guid},body:null}):valid}};return api}}),angular.module("keta.servicesEventBus",["keta.servicesAccessToken","keta.servicesLogger"]).provider("ketaEventBus",function(){var SERVICE_NAME="ketaEventBus",DEFAULT_RECONNECT_TIMEOUT=10,DEFAULT_SOCKET_URL="https://localhost:10443/kiwibus",STATE_CONNECTING=0,STATE_OPEN=1,STATE_CLOSING=2,STATE_CLOSED=3,STATE_UNKNOWN=4,STATE_LABELS={};STATE_LABELS[STATE_CONNECTING]="connecting",STATE_LABELS[STATE_OPEN]="open",STATE_LABELS[STATE_CLOSING]="closing",STATE_LABELS[STATE_CLOSED]="closed",STATE_LABELS[STATE_UNKNOWN]="unknown";var EVENT_CREATED="CREATED",EVENT_UPDATED="UPDATED",EVENT_DELETED="DELETED",EVENT_FAILED="FAILED",RESPONSE_CODE_OK=200,RESPONSE_CODE_BAD_REQUEST=400,RESPONSE_CODE_NOT_FOUND=404,RESPONSE_CODE_TIMEOUT=408,RESPONSE_CODE_AUTH_TOKEN_EXPIRED=419,RESPONSE_CODE_INTERNAL_SERVER_ERROR=500,RESPONSE_CODE_SERVICE_UNAVAILABLE=503,DEFAULT_SEND_TIMEOUT=10,config={socketURL:DEFAULT_SOCKET_URL,socketState:STATE_CLOSED,autoConnect:!1,reconnect:!0,reconnectTimeout:DEFAULT_RECONNECT_TIMEOUT,mockMode:!1,debugMode:!1,sendTimeout:DEFAULT_SEND_TIMEOUT},mocked={responses:{},handlers:{}},eventBus=null,onOpenHandlers={},onCloseHandlers={},busHandlers={};this.setSocketURL=function(url){config.socketURL=angular.isString(url)?String(url):DEFAULT_SOCKET_URL},this.enableAutoConnect=function(enabled){config.autoConnect=enabled===!0||enabled===!1?Boolean(enabled):!1},this.enableReconnect=function(enabled){config.reconnect=enabled===!0||enabled===!1?Boolean(enabled):!0},this.setReconnectTimeout=function(timeout){config.reconnectTimeout=angular.isDefined(timeout)&&angular.isNumber(timeout)&&timeout>0?timeout:DEFAULT_RECONNECT_TIMEOUT},this.enableMockMode=function(enabled){config.mockMode=enabled===!0||enabled===!1?Boolean(enabled):!1},this.enableDebugMode=function(enabled){config.debugMode=enabled===!0||enabled===!1?Boolean(enabled):!1},this.addMockResponse=function(id,callback){!angular.isDefined(mocked.responses[id])&&angular.isFunction(callback)&&(mocked.responses[id]=callback)},this.setSendTimeout=function(timeout){config.sendTimeout=angular.isDefined(timeout)&&angular.isNumber(timeout)&&timeout>0?timeout:DEFAULT_SEND_TIMEOUT},this.getConfig=function(){return config},this.getMocked=function(){return mocked},this.getEventBus=function(){return eventBus};var that=this;this.$get=function($rootScope,$location,$timeout,$window,ketaAccessToken,ketaLogger){DEFAULT_SOCKET_URL=$window.appContext.bus.url||DEFAULT_SOCKET_URL,config.socketURL=DEFAULT_SOCKET_URL;var openHandler=function(){config.socketState=STATE_OPEN,angular.forEach(onOpenHandlers,function(handler){angular.isFunction(handler)&&handler()})},closeHandler=function(){config.socketState=STATE_CLOSED,angular.forEach(onCloseHandlers,function(handler){angular.isFunction(handler)&&handler()}),config.reconnect&&$timeout(function(){stub.open()},1e3*config.reconnectTimeout)},matchMockHandler=function(message,response){angular.forEach(mocked.handlers,function(handlerConfig,id){angular.forEach(handlerConfig.actions,function(action){if(action===message.action){ketaLogger.debug(action+" matched for handler "+id,message,response);var type="";0===message.action.indexOf("create")&&(type=EVENT_CREATED),0===message.action.indexOf("update")&&(type=EVENT_UPDATED),0===message.action.indexOf("delete")&&(type=EVENT_DELETED),handlerConfig.handler({type:type,value:response.result})}})})};$rootScope.$on("$routeChangeStart",function(){angular.forEach(busHandlers,function(handler,uuid){stub.unregisterBusHandler(uuid,handler)}),busHandlers={},stub.send("devices",{action:"unregisterAllListeners",body:null})});var stub={EVENT_ON_OPEN:"onOpen",EVENT_ON_CLOSE:"onClose",EVENT_CREATED:EVENT_CREATED,EVENT_UPDATED:EVENT_UPDATED,EVENT_DELETED:EVENT_DELETED,EVENT_FAILED:EVENT_FAILED,RESPONSE_CODE_OK:RESPONSE_CODE_OK,RESPONSE_CODE_BAD_REQUEST:RESPONSE_CODE_BAD_REQUEST,RESPONSE_CODE_NOT_FOUND:RESPONSE_CODE_NOT_FOUND,RESPONSE_CODE_TIMEOUT:RESPONSE_CODE_TIMEOUT,RESPONSE_CODE_AUTH_TOKEN_EXPIRED:RESPONSE_CODE_AUTH_TOKEN_EXPIRED,RESPONSE_CODE_INTERNAL_SERVER_ERROR:RESPONSE_CODE_INTERNAL_SERVER_ERROR,RESPONSE_CODE_SERVICE_UNAVAILABLE:RESPONSE_CODE_SERVICE_UNAVAILABLE,getSocketURL:function(){return config.socketURL},getSocketState:function(){return config.socketState},getSocketStateLabel:function(){return angular.isDefined(STATE_LABELS[config.socketState])?STATE_LABELS[config.socketState]:STATE_LABELS[STATE_UNKNOWN]},autoConnectEnabled:function(){return config.autoConnect},reconnectEnabled:function(){return config.reconnect},getReconnectTimeout:function(){return config.reconnectTimeout},mockModeEnabled:function(){return config.mockMode},debugModeEnabled:function(){return config.debugMode},getConfig:that.getConfig,getMocked:that.getMocked,getEventBus:that.getEventBus,STATE_CONNECTING:STATE_CONNECTING,STATE_OPEN:STATE_OPEN,STATE_CLOSING:STATE_CLOSING,STATE_CLOSED:STATE_CLOSED,open:function(){config.socketState===STATE_CLOSED&&(ketaLogger.info(SERVICE_NAME+".open",stub.getConfig()),config.mockMode?(config.socketState=STATE_OPEN,openHandler()):(eventBus=new vertx.EventBus(config.socketURL),eventBus.onopen=openHandler,eventBus.onclose=closeHandler))},close:function(){config.socketState===STATE_OPEN&&(config.mockMode?(config.socketState=STATE_CLOSED,closeHandler()):stub.getEventBus().close())},getState:function(){var state=stub.getSocketState();return!config.mockMode&&stub.getEventBus()&&(state=stub.getEventBus().readyState()),state},send:function(address,message,responseHandler){if(ketaLogger.debug(SERVICE_NAME+".send » request to "+address+":"+message.action,message),config.socketState===STATE_OPEN)if(config.mockMode)if(angular.isDefined(message.action)&&angular.isDefined(mocked.responses[address+":"+message.action])){var reply=mocked.responses[address+":"+message.action](message);ketaLogger.debug(SERVICE_NAME+".send « response (mocked) from "+address+":"+message.action,message,reply),angular.isFunction(responseHandler)&&responseHandler(reply),matchMockHandler(message,reply)}else ketaLogger.warning(SERVICE_NAME+".send « no mocked response for "+address+":"+message.action+" found",message),angular.isFunction(responseHandler)&&responseHandler({code:stub.RESPONSE_CODE_NOT_FOUND,message:"No mocked response for "+address+":"+message.action+" found"});else{message.accessToken=ketaAccessToken.get();var requestReturned=!1;$timeout(function(){!requestReturned&&angular.isFunction(responseHandler)&&(ketaLogger.error(SERVICE_NAME+".send « response for "+address+":"+message.action+" timed out",message),requestReturned=!0,responseHandler({code:stub.RESPONSE_CODE_TIMEOUT,message:"Response for "+address+":"+message.action+" timed out"}))},1e3*config.sendTimeout),stub.getEventBus().send(address,message,function(reply){!requestReturned&&reply&&(requestReturned=!0,angular.isDefined(reply.code)?reply.code===stub.RESPONSE_CODE_AUTH_TOKEN_EXPIRED?ketaAccessToken.refresh().then(function(response){angular.isDefined(response.data.accessToken)&&(ketaAccessToken.set(response.data.accessToken),stub.send(address,message,responseHandler))},function(){$window.location.reload()}):(ketaLogger.debug(SERVICE_NAME+".send « response from "+address+":"+message.action,message,reply),angular.isFunction(responseHandler)&&responseHandler(reply)):(ketaLogger.error(SERVICE_NAME+".send « response for "+address+":"+message.action+' was "Bad request"',message),responseHandler({code:stub.RESPONSE_CODE_BAD_REQUEST,message:"Bad request"})))})}else ketaLogger.error(SERVICE_NAME+".send « request to "+address+":"+message.action+" denied. EventBus not open.",message),angular.isFunction(responseHandler)&&responseHandler({code:stub.RESPONSE_CODE_SERVICE_UNAVAILABLE,message:"EventBus not open"})},publish:function(address,message){ketaLogger.debug(SERVICE_NAME+".publish » request to "+address+":"+message.action,message),config.socketState===STATE_OPEN?!config.mockMode&&stub.getEventBus()&&(message.accessToken=ketaAccessToken.get(),stub.getEventBus().publish(address,message)):ketaLogger.error(SERVICE_NAME+".publish « request to "+address+":"+message.action+" denied. EventBus not open.",message)},registerBusHandler:function(uuid,handler,actions){ketaLogger.debug(SERVICE_NAME+".registerBusHandler » request for "+uuid,actions),config.socketState===STATE_OPEN?!config.mockMode&&stub.getEventBus()?(stub.getEventBus().registerHandler(uuid,handler),busHandlers[uuid]=handler):angular.isDefined(mocked.handlers[uuid])?ketaLogger.warning(SERVICE_NAME+".registerBusHandler « no mocked response found",mocked.handlers[uuid].actions):(mocked.handlers[uuid]={handler:handler,actions:actions},ketaLogger.info(SERVICE_NAME+".registerBusHandler "+uuid+" in mock mode",mocked.handlers[uuid].actions)):ketaLogger.error(SERVICE_NAME+".registerBusHandler « request for "+uuid+" denied. EventBus not open.",actions)},unregisterBusHandler:function(uuid,handler){if(ketaLogger.debug(SERVICE_NAME+".unregisterBusHandler » request for "+uuid),config.socketState===STATE_OPEN)if(!config.mockMode&&stub.getEventBus())stub.getEventBus().unregisterHandler(uuid,handler);else if(angular.isDefined(mocked.handlers[uuid])){var handlers=[];angular.forEach(mocked.handlers[uuid],function(h){handler!==h&&handlers.push(h)}),mocked.handlers[uuid]=handlers,ketaLogger.info(SERVICE_NAME+".unregisterBusHandler "+uuid+" in mock mode")}else ketaLogger.warning(SERVICE_NAME+".unregisterBusHandler « no mocked response found");else ketaLogger.error(SERVICE_NAME+".unregisterBusHandler « request for "+uuid+" denied. EventBus not open.")},registerEventHandler:function(event,uuid,handler){event===stub.EVENT_ON_OPEN&&(angular.isDefined(onOpenHandlers[uuid])||(onOpenHandlers[uuid]=handler)),event===stub.EVENT_ON_CLOSE&&(angular.isDefined(onCloseHandlers[uuid])||(onCloseHandlers[uuid]=handler))},unregisterEventHandler:function(event,uuid){event===stub.EVENT_ON_OPEN&&angular.isDefined(onOpenHandlers[uuid])&&delete onOpenHandlers[uuid],event===stub.EVENT_ON_CLOSE&&angular.isDefined(onCloseHandlers[uuid])&&delete onCloseHandlers[uuid]},generateUUID:function(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,function(a,b){return b=16*Math.random(),("y"===a?3&b|8:0|b).toString(16)})}};return config.autoConnect&&stub.open(),stub}}),angular.module("keta.servicesLogger",[]).provider("ketaLogger",function(){var LOG_LEVEL_ERROR=1,LOG_LEVEL_WARNING=2,LOG_LEVEL_INFO=4,LOG_LEVEL_DEBUG=8,LOG_LEVEL_ALL=LOG_LEVEL_ERROR|LOG_LEVEL_WARNING|LOG_LEVEL_INFO|LOG_LEVEL_DEBUG,LOG_LEVEL_MAPPINGS={};LOG_LEVEL_MAPPINGS[LOG_LEVEL_ERROR]="ERROR",LOG_LEVEL_MAPPINGS[LOG_LEVEL_WARNING]="WARNING",LOG_LEVEL_MAPPINGS[LOG_LEVEL_INFO]="INFO",LOG_LEVEL_MAPPINGS[LOG_LEVEL_DEBUG]="DEBUG",LOG_LEVEL_MAPPINGS[LOG_LEVEL_ALL]="ALL";var getLevelMapping=function(level){return angular.isDefined(LOG_LEVEL_MAPPINGS[level])?LOG_LEVEL_MAPPINGS[level]:"LEVEL "+level},SIMPLE_LOGGER=function(level,message,request,response){config.enabled&&config.level&level&&console.log(getLevelMapping(level),message,request,response)},ADVANCED_LOGGER=function(level,message,request,response){if(config.enabled&&config.level&level){var colors={lime:"color:#acbf2f;",yellow:"color:#f7b600;",red:"color:#ff0000;",lightGrey:"color:#999;",darkGrey:"color:#333;"},weights={lighter:"font-weight:lighter;",normal:"font-weight:normal;",bold:"font-weight:bold",bolder:"font-weight:bolder"},style=colors.lime+weights.bold,reset=colors.darkGrey+weights.normal;level===LOG_LEVEL_ERROR?style=colors.red+weights.bold:level===LOG_LEVEL_WARNING&&(style=colors.yellow+weights.bold),console.log("%c["+getLevelMapping(level)+" – "+(new Date).toISOString()+"]\n%c"+message+"\n%c"+(angular.isDefined(request)?JSON.stringify(request,null,4)+"\n":"")+"%c"+(angular.isDefined(response)?JSON.stringify(response,null,4)+"\n":""),style,reset,colors.lightGrey,colors.darkGrey)}},config={enabled:!1,level:LOG_LEVEL_ERROR,logger:SIMPLE_LOGGER};this.LOG_LEVEL_ERROR=LOG_LEVEL_ERROR,this.LOG_LEVEL_WARNING=LOG_LEVEL_WARNING,this.LOG_LEVEL_INFO=LOG_LEVEL_INFO,this.LOG_LEVEL_DEBUG=LOG_LEVEL_DEBUG,this.LOG_LEVEL_ALL=LOG_LEVEL_ALL,this.LOG_LEVEL_MAPPINGS=LOG_LEVEL_MAPPINGS,this.getLevelMapping=getLevelMapping,this.SIMPLE_LOGGER=SIMPLE_LOGGER,this.ADVANCED_LOGGER=ADVANCED_LOGGER,this.enableLogging=function(){config.enabled=!0},this.disableLogging=function(){config.enabled=!1},this.setLevel=function(level){angular.isNumber(level)&&(config.level=level)},this.setLogger=function(logger){angular.isFunction(logger)&&(config.logger=logger)},this.getConfig=function(){return config};var that=this;this.$get=function(){var api={LOG_LEVEL_ERROR:LOG_LEVEL_ERROR,LOG_LEVEL_WARNING:LOG_LEVEL_WARNING,LOG_LEVEL_INFO:LOG_LEVEL_INFO,LOG_LEVEL_DEBUG:LOG_LEVEL_DEBUG,LOG_LEVEL_ALL:LOG_LEVEL_ALL,LOG_LEVEL_MAPPINGS:LOG_LEVEL_MAPPINGS,getLevelMapping:that.getLevelMapping,SIMPLE_LOGGER:that.SIMPLE_LOGGER,ADVANCED_LOGGER:that.ADVANCED_LOGGER,enableLogging:that.enableLogging,disableLogging:that.disableLogging,getLevel:function(){return config.level},setLevel:that.setLevel,setLogger:that.setLogger,log:function(level,message,request,response){config.logger(level,message,request,response)},error:function(message,request,response){this.log(LOG_LEVEL_ERROR,message,request,response)},warning:function(message,request,response){this.log(LOG_LEVEL_WARNING,message,request,response)},info:function(message,request,response){this.log(LOG_LEVEL_INFO,message,request,response)},debug:function(message,request,response){this.log(LOG_LEVEL_DEBUG,message,request,response)}};return api}}),angular.module("keta.servicesTag",["keta.servicesEventBus","keta.servicesLogger"]).provider("ketaTag",function(){var SERVICE_ENDPOINT="devices",ERROR_INVALID_SAMPLE_RATE="Invalid sample rate",ERROR_INVALID_HANDLER="Invalid handler";this.$get=function($q,ketaEventBus,ketaLogger){var responsePromise=function(message,resolve){var deferred=$q.defer();return resolve?deferred.resolve(message):deferred.reject(message),deferred.promise},api={ERROR_INVALID_SAMPLE_RATE:ERROR_INVALID_SAMPLE_RATE,ERROR_INVALID_HANDLER:ERROR_INVALID_HANDLER,registerListener:function(filter,sampleRate,handler){if(!angular.isNumber(sampleRate)||5>sampleRate)return responsePromise({code:ketaEventBus.RESPONSE_CODE_BAD_REQUEST,message:ERROR_INVALID_SAMPLE_RATE},!1);if(!angular.isFunction(handler))return responsePromise({code:ketaEventBus.RESPONSE_CODE_BAD_REQUEST,message:ERROR_INVALID_HANDLER},!1);var deferred=$q.defer(),listenerUUID="CLIENT_"+ketaEventBus.generateUUID()+"_tagValueListener";return ketaEventBus.registerBusHandler(listenerUUID,handler),ketaEventBus.send(SERVICE_ENDPOINT,{action:"registerTagValueListener",body:{deviceFilter:filter,sampleRate:sampleRate,replyAddress:listenerUUID}},function(response){response.code===ketaEventBus.RESPONSE_CODE_OK?deferred.resolve(response):(ketaLogger.info(SERVICE_ENDPOINT+":registerTagValueListener",response),deferred.reject(response.message))}),deferred.promise}};return api}});
//# sourceMappingURL=keta.min.js.map