"use strict";angular.module("keta.servicesAccessToken",["keta.servicesAppContext"]).factory("ketaAccessToken",function($http,ketaAppContext){var accessToken=ketaAppContext.get("oauth.accessToken"),api={get:function(){return accessToken},set:function(token){angular.isDefined(token)&&angular.isString(token)&&(accessToken=token)},refresh:function(){return $http({method:"GET",url:"/refreshAccessToken"})}};return api}),angular.module("keta.servicesAppContext",[]).factory("ketaAppContext",function($window){var appContext=angular.isDefined($window.appContext)?$window.appContext:"",api={get:function(key){var obj=appContext;key=key.split(".");for(var i=0,l=key.length;l>i;i++){if(!angular.isDefined(obj[key[i]]))return null;obj=obj[key[i]]}return obj}};return api}),angular.module("keta.servicesDevice",["keta.servicesEventBus"]).provider("ketaDevice",function(){var SERVICE_NAME="ketaDevice",SERVICE_ENDPOINT="devices",ERROR_NO_GUID="No guid found in device object";this.$get=function($rootScope,$q,$location,ketaEventBus){var equals=function(deviceOne,deviceTwo){var matches=angular.isDefined(deviceOne.guid)&&angular.isDefined(deviceTwo.guid)&&deviceOne.guid===deviceTwo.guid;return matches},indexOfItem=function(item,list){var index=-1;return angular.forEach(list,function(object,idx){-1===index&&equals(item,object)&&(index=idx)}),index},processEvent=function(message,devices){if(angular.isDefined(message.type)&&angular.isDefined(message.value)&&angular.isDefined(message.value.guid)){var device=message.value;if(device.$$pristine=angular.copy(device),message.type===ketaEventBus.EVENT_CREATED)devices.push(device),ketaEventBus.log(SERVICE_NAME+':processEvent » device with guid "'+device.guid+'" created',device),$rootScope.$apply();else{var index=indexOfItem(device,devices);-1!==index?(message.type===ketaEventBus.EVENT_UPDATED&&(devices[index]=device,ketaEventBus.log(SERVICE_NAME+':processEvent » device with guid "'+device.guid+'" updated',device)),message.type===ketaEventBus.EVENT_DELETED&&(devices.splice(index,1),ketaEventBus.log(SERVICE_NAME+':processEvent » device with guid "'+device.guid+'" deleted',device)),$rootScope.$apply()):ketaEventBus.log(SERVICE_NAME+':processEvent » device with guid "'+device.guid+'" not found')}}},processAction=function(message,registerListener){var deferred=$q.defer();return ketaEventBus.send(SERVICE_ENDPOINT,message,function(response){if(angular.isDefined(response.code)&&angular.isDefined(response.result)&&response.code===ketaEventBus.RESPONSE_CODE_OK){if(registerListener){var listenerUUID="CLIENT_"+ketaEventBus.generateUUID()+"_deviceSetListener",deviceFilter={};angular.isDefined(message.params)&&null!==message.params&&angular.isDefined(message.params.filter)&&angular.isDefined(message.params.filter.guid)&&(deviceFilter={guid:message.params.filter.guid}),ketaEventBus.registerBusHandler(listenerUUID,function(message){processEvent(message,response.result.items)}),ketaEventBus.send(SERVICE_ENDPOINT,{action:"registerDeviceSetListener",body:{deviceFilter:deviceFilter,deviceProjection:{},replyAddress:listenerUUID}},function(listenerResponse){listenerResponse.code!==ketaEventBus.RESPONSE_CODE_OK&&ketaEventBus.log(SERVICE_ENDPOINT+":registerDeviceSetListener",listenerResponse.message)}),response.result.$$listenerUUID=listenerUUID,angular.forEach(response.result.items,function(item){item.$$pristine=angular.copy(item)})}angular.isDefined(response.result.items)?deferred.resolve(response.result.items,response.result.offset,response.result.limit,response.result.total):deferred.resolve(response.result)}else deferred.reject(angular.isDefined(response.message)?response.message:"Unknown error")},function(error){deferred.reject(error)}),deferred.promise},responsePromise=function(message,resolve){var deferred=$q.defer();return resolve?deferred.resolve(message):deferred.reject(message),deferred.promise},getChanges=function(prev,current){var changes={},prop=null;for(prop in current)if(current.hasOwnProperty(prop)&&(!prev||prev[prop]!==current[prop]))if("object"==typeof current[prop]){var c=getChanges(prev[prop],current[prop]);c&&(changes[prop]=c)}else changes[prop]=current[prop];for(prop in changes)if(changes.hasOwnProperty(prop))return changes;return!1},api={ERROR_NO_GUID:ERROR_NO_GUID,read:function(params){return processAction({action:"getDevices",params:angular.isDefined(params)?params:null,body:null},!0)},create:function(device){return angular.isDefined(device.guid)?processAction({action:"createDevice",params:null,body:device}):responsePromise({code:ketaEventBus.RESPONSE_CODE_BAD_REQUEST,message:ERROR_NO_GUID},!1)},update:function(device){if(!angular.isDefined(device.guid))return responsePromise({code:ketaEventBus.RESPONSE_CODE_BAD_REQUEST,message:ERROR_NO_GUID},!1);var originalDevice=angular.copy(device.$$pristine),updatedDevice=angular.copy(device);delete updatedDevice.$$pristine;var changes=getChanges(originalDevice,updatedDevice);return changes?(angular.forEach(changes.tagValues,function(tagValue,tagName){changes.tagValues[tagName].oca=updatedDevice.tagValues[tagName].oca}),processAction({action:"updateDevice",params:{deviceId:device.guid},body:changes})):responsePromise(device,!0)},"delete":function(device){return angular.isDefined(device.guid)?processAction({action:"deleteDevice",params:{deviceId:device.guid},body:null}):responsePromise({code:ketaEventBus.RESPONSE_CODE_BAD_REQUEST,message:ERROR_NO_GUID},!1)}};return api}}),angular.module("keta.servicesEventBus",["keta.servicesAccessToken"]).provider("ketaEventBus",function(){var SERVICE_NAME="ketaEventBus",DEFAULT_RECONNECT_TIMEOUT=10,DEFAULT_SOCKET_URL="https://localhost:10443/kiwibus",STATE_CONNECTING=0,STATE_OPEN=1,STATE_CLOSING=2,STATE_CLOSED=3,STATE_UNKNOWN=4,STATE_LABELS={};STATE_LABELS[STATE_CONNECTING]="connecting",STATE_LABELS[STATE_OPEN]="open",STATE_LABELS[STATE_CLOSING]="closing",STATE_LABELS[STATE_CLOSED]="closed",STATE_LABELS[STATE_UNKNOWN]="unknown";var EVENT_CREATED="CREATED",EVENT_UPDATED="UPDATED",EVENT_DELETED="DELETED",RESPONSE_CODE_OK=200,RESPONSE_CODE_BAD_REQUEST=400,RESPONSE_CODE_NOT_FOUND=404,RESPONSE_CODE_TIMEOUT=408,RESPONSE_CODE_AUTH_TOKEN_EXPIRED=419,DEFAULT_SEND_TIMEOUT=10,config={socketURL:DEFAULT_SOCKET_URL,socketState:STATE_CLOSED,autoConnect:!1,reconnect:!0,reconnectTimeout:DEFAULT_RECONNECT_TIMEOUT,mockMode:!1,debugMode:!1,logFilter:null,sendTimeout:DEFAULT_SEND_TIMEOUT},mocked={responses:{},handlers:{}},eventBus=null,onOpenHandlers={},onCloseHandlers={},busHandlers={};this.setSocketURL=function(url){config.socketURL=angular.isString(url)?String(url):DEFAULT_SOCKET_URL},this.enableAutoConnect=function(enabled){config.autoConnect=enabled===!0||enabled===!1?Boolean(enabled):!1},this.enableReconnect=function(enabled){config.reconnect=enabled===!0||enabled===!1?Boolean(enabled):!0},this.setReconnectTimeout=function(timeout){config.reconnectTimeout=angular.isDefined(timeout)&&angular.isNumber(timeout)&&timeout>0?timeout:DEFAULT_RECONNECT_TIMEOUT},this.enableMockMode=function(enabled){config.mockMode=enabled===!0||enabled===!1?Boolean(enabled):!1},this.enableDebugMode=function(enabled){config.debugMode=enabled===!0||enabled===!1?Boolean(enabled):!1},this.addMockResponse=function(id,callback){!angular.isDefined(mocked.responses[id])&&angular.isFunction(callback)&&(mocked.responses[id]=callback)},this.setLogFilter=function(filter){angular.isFunction(filter)&&(config.logFilter=filter)},this.setSendTimeout=function(timeout){config.sendTimeout=angular.isDefined(timeout)&&angular.isNumber(timeout)&&timeout>0?timeout:DEFAULT_SEND_TIMEOUT},this.getConfig=function(){return config},this.getMocked=function(){return mocked},this.getEventBus=function(){return eventBus};var that=this;this.$get=function($rootScope,$location,$timeout,$window,ketaAccessToken){DEFAULT_SOCKET_URL=$window.appContext.bus.url||DEFAULT_SOCKET_URL,config.socketURL=DEFAULT_SOCKET_URL;var openHandler=function(){config.socketState=STATE_OPEN,angular.forEach(onOpenHandlers,function(handler){angular.isFunction(handler)&&handler()})},closeHandler=function(){config.socketState=STATE_CLOSED,angular.forEach(onCloseHandlers,function(handler){angular.isFunction(handler)&&handler()}),config.reconnect&&$timeout(function(){stub.open()},1e3*config.reconnectTimeout)},matchMockHandler=function(message,response){angular.forEach(mocked.handlers,function(handlerConfig,id){angular.forEach(handlerConfig.actions,function(action){if(action===message.action){stub.log(action+" matched for handler "+id);var type="";0===message.action.indexOf("create")&&(type=EVENT_CREATED),0===message.action.indexOf("update")&&(type=EVENT_UPDATED),0===message.action.indexOf("delete")&&(type=EVENT_DELETED),handlerConfig.handler({type:type,value:response.result})}})})};$rootScope.$on("$routeChangeStart",function(){angular.forEach(busHandlers,function(handler,uuid){stub.unregisterBusHandler(uuid,handler)}),busHandlers={}});var stub={EVENT_ON_OPEN:"onOpen",EVENT_ON_CLOSE:"onClose",EVENT_CREATED:EVENT_CREATED,EVENT_UPDATED:EVENT_UPDATED,EVENT_DELETED:EVENT_DELETED,RESPONSE_CODE_OK:RESPONSE_CODE_OK,RESPONSE_CODE_BAD_REQUEST:RESPONSE_CODE_BAD_REQUEST,RESPONSE_CODE_NOT_FOUND:RESPONSE_CODE_NOT_FOUND,RESPONSE_CODE_TIMEOUT:RESPONSE_CODE_TIMEOUT,RESPONSE_CODE_AUTH_TOKEN_EXPIRED:RESPONSE_CODE_AUTH_TOKEN_EXPIRED,getSocketURL:function(){return config.socketURL},getSocketState:function(){return config.socketState},getSocketStateLabel:function(){return angular.isDefined(STATE_LABELS[config.socketState])?STATE_LABELS[config.socketState]:STATE_LABELS[STATE_UNKNOWN]},autoConnectEnabled:function(){return config.autoConnect},reconnectEnabled:function(){return config.reconnect},getReconnectTimeout:function(){return config.reconnectTimeout},mockModeEnabled:function(){return config.mockMode},debugModeEnabled:function(){return config.debugMode},getConfig:that.getConfig,getMocked:that.getMocked,getEventBus:that.getEventBus,log:function(headline,data){var logToConsole=function(headline,data){console.log("%c["+(new Date).toUTCString()+"]\n%c"+headline+"\n%c"+(angular.isDefined(data)?JSON.stringify(data,null,4)+"\n":""),"color:#acbf2f","color:#999","color:#333")};config.debugMode&&(null===config.logFilter||angular.isFunction(config.logFilter)&&config.logFilter(headline,data))&&logToConsole(headline,data)},STATE_CONNECTING:STATE_CONNECTING,STATE_OPEN:STATE_OPEN,STATE_CLOSING:STATE_CLOSING,STATE_CLOSED:STATE_CLOSED,open:function(){config.socketState===STATE_CLOSED&&(stub.log(SERVICE_NAME+".open",stub.getConfig()),config.mockMode?(config.socketState=STATE_OPEN,openHandler()):(eventBus=new vertx.EventBus(config.socketURL),eventBus.onopen=openHandler,eventBus.onclose=closeHandler))},close:function(){config.socketState===STATE_OPEN&&(config.mockMode?(config.socketState=STATE_CLOSED,closeHandler()):stub.getEventBus().close())},getState:function(){var state=stub.getSocketState();return!config.mockMode&&stub.getEventBus()&&(state=stub.getEventBus().readyState()),state},send:function(address,message,responseHandler){if(stub.log(SERVICE_NAME+".send » request to "+address+":"+message.action,message),config.mockMode||config.socketState!==STATE_OPEN)if(angular.isDefined(message.action)&&angular.isDefined(mocked.responses[address+":"+message.action])){var response=mocked.responses[address+":"+message.action](message);stub.log(SERVICE_NAME+".send « response (mocked) from "+address+":"+message.action,response),angular.isFunction(responseHandler)&&responseHandler(response),matchMockHandler(message,response)}else angular.isFunction(responseHandler)&&responseHandler({code:stub.RESPONSE_CODE_NOT_FOUND,message:"No mocked response for "+address+":"+message.action+" found"});else{message.accessToken=ketaAccessToken.get();var requestReturned=!1;$timeout(function(){!requestReturned&&angular.isFunction(responseHandler)&&responseHandler({code:stub.RESPONSE_CODE_TIMEOUT,message:"Response for "+address+":"+message.action+" timed out"})},1e3*config.sendTimeout),stub.getEventBus().send(address,message,function(reply){requestReturned=!0,reply.code===stub.RESPONSE_CODE_AUTH_TOKEN_EXPIRED?ketaAccessToken.refresh().then(function(response){angular.isDefined(response.data.accessToken)&&(ketaAccessToken.set(response.data.accessToken),stub.send(address,message,responseHandler))},function(error){console.error(error)}):(stub.log(SERVICE_NAME+".send « response from "+address+":"+message.action,reply),angular.isFunction(responseHandler)&&responseHandler(reply))})}},publish:function(address,message){!config.mockMode&&stub.getEventBus()&&(message.accessToken=ketaAccessToken.get(),stub.getEventBus().publish(address,message))},registerBusHandler:function(uuid,handler,actions){!config.mockMode&&stub.getEventBus()?(stub.getEventBus().registerHandler(uuid,handler),busHandlers[uuid]=handler,stub.log(SERVICE_NAME+".registerBusHandler "+uuid)):angular.isDefined(mocked.handlers[uuid])||(mocked.handlers[uuid]={handler:handler,actions:actions},stub.log(SERVICE_NAME+".registerBusHandler "+uuid,mocked.handlers[uuid].actions))},unregisterBusHandler:function(uuid,handler){if(!config.mockMode&&stub.getEventBus())stub.getEventBus().unregisterHandler(uuid,handler),stub.log(SERVICE_NAME+".unregisterBusHandler "+uuid);else if(angular.isDefined(mocked.handlers[uuid])){var handlers=[];angular.forEach(mocked.handlers[uuid],function(h){handler!==h&&handlers.push(h)}),mocked.handlers[uuid]=handlers,stub.log(SERVICE_NAME+".unregisterBusHandler "+uuid)}},registerEventHandler:function(event,uuid,handler){event===stub.EVENT_ON_OPEN&&(angular.isDefined(onOpenHandlers[uuid])||(onOpenHandlers[uuid]=handler)),event===stub.EVENT_ON_CLOSE&&(angular.isDefined(onCloseHandlers[uuid])||(onCloseHandlers[uuid]=handler))},unregisterEventHandler:function(event,uuid){event===stub.EVENT_ON_OPEN&&angular.isDefined(onOpenHandlers[uuid])&&delete onOpenHandlers[uuid],event===stub.EVENT_ON_CLOSE&&angular.isDefined(onCloseHandlers[uuid])&&delete onCloseHandlers[uuid]},generateUUID:function(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,function(a,b){return b=16*Math.random(),("y"===a?3&b|8:0|b).toString(16)})}};return config.autoConnect&&stub.open(),stub}}),angular.module("keta.servicesTag",["keta.servicesEventBus"]).provider("ketaTag",function(){var SERVICE_ENDPOINT="devices",ERROR_INVALID_SAMPLE_RATE="Invalid sample rate",ERROR_INVALID_HANDLER="Invalid handler";this.$get=function($q,ketaEventBus){var responsePromise=function(message,resolve){var deferred=$q.defer();return resolve?deferred.resolve(message):deferred.reject(message),deferred.promise},api={ERROR_INVALID_SAMPLE_RATE:ERROR_INVALID_SAMPLE_RATE,ERROR_INVALID_HANDLER:ERROR_INVALID_HANDLER,registerListener:function(filter,sampleRate,handler){if(!angular.isNumber(sampleRate)||5>sampleRate)return responsePromise({code:ketaEventBus.RESPONSE_CODE_BAD_REQUEST,message:ERROR_INVALID_SAMPLE_RATE},!1);if(!angular.isFunction(handler))return responsePromise({code:ketaEventBus.RESPONSE_CODE_BAD_REQUEST,message:ERROR_INVALID_HANDLER},!1);var deferred=$q.defer(),listenerUUID="CLIENT_"+ketaEventBus.generateUUID()+"_tagValueListener";return ketaEventBus.registerBusHandler(listenerUUID,handler),ketaEventBus.send(SERVICE_ENDPOINT,{action:"registerTagValueListener",body:{deviceFilter:filter,sampleRate:sampleRate,replyAddress:listenerUUID}},function(listenerResponse){listenerResponse.code===ketaEventBus.RESPONSE_CODE_OK?deferred.resolve(listenerResponse):(ketaEventBus.log(SERVICE_ENDPOINT+":registerTagValueListener",listenerResponse.message),deferred.reject(listenerResponse.message))}),deferred.promise}};return api}});
//# sourceMappingURL=keta.min.js.map